/*
;*--------------------------------------------- é–ºå‚šæ´£å¨†ãˆ¡ç©±éˆ©å†§ç´? ----------------------------------------------------
;* é–ºå‚šæ´£å¨†ãˆ¤å´¥å®¥å›†ï¿? : 1111111
;* é–ºå‚šæ´£å¨†ãˆ¤å´é”è¯²å? :
;* éæ¶–å„±é˜æ «æ‹ ç€›æ¨»î? :
;*-------------------------------------------- é–ºå ¬æ‹·é–ºå‚›å£†æ¾§æ¥…å¼µé¡‘å¤¸ç¹†é–¹î…¨æ‹? -------------------------------------------------
;* å¨£å›¶å–—éå…¼æ‹…å©Šå—­æ‹·é”Ÿï¿? :
;* å¨£å›¶å–—éå¥¸å¼®éŠ‰ï¸½åŸ? :
;* é–»æ¥€ç‰Šå©€ç‰ˆç«Ÿé—å Ÿî? :
;*-------------------------------------------- é–¸æ¨ºæ£—è¤°å •æ‚§é«ç†¸æ‹±å¨£å›£å‰æµ¼ï¿½ -------------------------------------------------
;* é–ºå‚šæ´£å¨†ãˆ¡æ‹…å©Šå—­æ‹·é”Ÿï¿? : liujunjie_2008@126.com
;* é–¸æ“ç¨‘ç¼‚æ’»å¼®éŠ‰ï¸½åŸ? :
;* é–»æ¥€ç‰Šå©€ç‰ˆç«Ÿé—å Ÿî? :
;************************************************************************************************************
*/
#include "sensor_basic.h"

/********************************************************************************
** é–¸æˆ£å§¤é†ç†¼å´¥å®¥å›†ï¿? é–¿æ¶³æ‹?
** é–¸æˆ£å§¤é†ç†¼å´é”è¯²å? é–¿æ¶³æ‹?
** é–¸å¿‹å„±è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
**
** é–¸æˆæ«è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
********************************************************************************
*/
void hal_sensor_init(void)
{
    Sensor_Init();

    SampleData_Init(&sensors_data);
}

/*
********************************************************************************
** é–¸æˆ£å§¤é†ç†¼å´¥å®¥å›†ï¿? é–¿æ¶™î„¯nsigned char Sensor_Init(void)
** é–¸æˆ£å§¤é†ç†¼å´é”è¯²å? é–¿æ¶™ç¢é¨ç”¸å´¢ç€£â•ƒç‚Šé–¹æ‰®å–å¨…æ—å´šå©µå—©æ½—é–¸æ µæ‹?
** é–¸å¿‹å„±è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
**
** é–¸æˆæ«è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
********************************************************************************
*/
unsigned char Sensor_Init(void)
{
    AirH_Init();
    return 1;
}

/*==================================================================
*é‘èŠ¥æšŸé”›ï¿?              AirH_rotronic
*æµ£æ»†ï¿½å’ƒç´?    ly
*éƒãƒ¦æ¹¡é”›ï¿?           2018-01-11
*é”ç†»å…˜é”›ï¿? æ¾¶å‹­æ‚Šç¼ƒæ¥?å´œçç…å å©?å®å®³æµ¼çŠ³åŠ…é£îŸ’ç´æ¶“æ’å½›éç‰ˆåµ
*æˆæ’³å†é”›ï¿?          char *buf (æˆæ’³å†éç‰ˆåµ)æˆæ’³å†éç‰ˆåµç€›æ¥ƒîƒæ¶“ï¿?
*        float *result        (æˆæ’³åš­éç‰ˆåµ)éºÑƒåŸ—ç¼æ’´ç€¯é¦æ¿æ½ƒ
*æ©æ–¿æ´–é”›ï¿?         éƒï¿½
*æ·‡î†½æ•¼ç’æ¿ç¶é”›ï¿½
==================================================================*/
void AirH_rotronic(char *buf,float *result)
{
    char *p = NULL, i = 0;
    float temp[3];

    p = strtok(buf, ";");
    while(p)
    {
       if(1 == i)  {temp[0] = atof(p);} //å©?å®å®³
       if(5 == i)  {temp[1] = atof(p);} //å¨“â•å®?
       if(10 == i) {temp[2] = atof(p);} //é—‡èŒ¬å?

       p = strtok(NULL, ";");
       i++;
    }

    *result = temp[0];
    *(++result) = temp[2];
    *(++result) = temp[1];
}

/*********************************************************************************
** é–¸æˆ£å§¤é†ç†¼å´¥å®¥å›†ï¿? é–¿æ¶™î„¯nsigned char AirH_engine(float *result)
** é–¸æˆ£å§¤é†ç†¼å´é”è¯²å? é–¿æ¶™ä¿ºé¡•ä¼´å´£éã„§æ¯œé–¸æ¨ºîƒ†é†ç†¼å¹‘é”Ÿï¿?
** é–¸å¿‹å„±è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
**
** é–¸æˆæ«è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?0é–¿æ¶™ç¢é¡’æ»ˆå´·éŠŠîŸ‘åš¢é–¸æ¬ç‰”é‘µï¿½ 1é–¿æ¶™ä¿ºé¡•ä¼´å´£éã„¥ç‡é–¸æ—“æ‹·  2é–¿æ¶™ä¿ºé¡•ä¼´å´£éÑƒæ¯‰é—åŒ¡æ‹?
*********************************************************************************/
unsigned char AirH_engine(float *result)
{ 
    UINT8 buffer[10];
    UINT32 count = 50;


    unsigned char phase = AirH_USART3_GetProcessingPhase();

    if(phase == USART_PROCESSING_IDEL)												// é–¸æ‹å€–éŒå›¬å¼°é¡–æ°­å„Šç¼å±¾æ¤½å¦«ï¿½
    {
        TxRxIndex = 0;
        TxRxLength = 0;
        strcpy((char *)buffer,"{F00RDD}\r\n");
        RevStep = 1;
        uartSendStr(UARTDEV_3, (UINT8 *)&buffer, sizeof("{F00RDD}\r\n") - 1);

        UartProcessingPhase = USART_PROCESSING_SENDING;

        while(count--)
        {                
            if(USART_PROCESSING_FINISH == UartProcessingPhase)
            {
                AirH_USART3_ResetProcessingPhase();

                if(TxRxLength != 104)  
                {
                    result[0] = INVALID_DATA;
                    result[1] = INVALID_DATA;
                    result[2] = INVALID_DATA;

                }
                else
                {                    
                    AirH_rotronic(TxRxBuffer, result);
                }

                TxRxIndex = 0;
                TxRxLength = 0;

                break;
            }
            
            if(USART_PROCESSING_ERR == UartProcessingPhase)
            {
                TxRxIndex = 0;
                TxRxLength = 0;

                AirH_USART3_ResetProcessingPhase();

                result[0] = INVALID_DATA;
                result[1] = INVALID_DATA;
                result[2] = INVALID_DATA;

                break;
            }
        }

        if(count <= 0)
        {
            TxRxIndex = 0;
            TxRxLength = 0;

            AirH_USART3_ResetProcessingPhase();

            result[0] = INVALID_DATA;
            result[1] = INVALID_DATA;
            result[2] = INVALID_DATA;
        }
    }
    else           
    {
        TxRxIndex = 0;
        TxRxLength = 0;

        AirH_USART3_ResetProcessingPhase();

        result[0] = INVALID_DATA;
        result[1] = INVALID_DATA;
        result[2] = INVALID_DATA;
    }
    
    return 1;
}
/*******************************************************************************
** é–¸æˆ£å§¤é†ç†¼å´¥å®¥å›†ï¿? é–¿æ¶™î„°oid Reset_Sensor(void)
** é–¸æˆ£å§¤é†ç†¼å´é”è¯²å? é–¿æ¶³æ‹?
** é–¸å¿‹å„±è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
**
** é–¸æˆæ«è¤°æ¶¢å´£éŒæ¶™æ®? é–¿æ¶³æ‹?
*******************************************************************************/
void Reset_Sensor(void)
{
    AirH_Init();
}


